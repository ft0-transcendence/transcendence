import { PrismaClient, TournamentRound, Prisma, Game, Tournament } from "@prisma/client";
import { AIPlayerService } from "../src/services/aiPlayerService";
import { app } from "../main";
import { mapTournamentGamesToDTO } from "../src/trpc/routes/tournament";
import { db } from "../src/trpc/db";

//TODO: Remove this shit
export const EMPTY_SLOT_USERNAME = 'Empty slot';
export const PLACEHOLDER_EMAIL = 'tournament-empty-slot@system.local';

export type BracketNode = {
	gameId: string;
	round: number;
	position: number;
	leftPlayerId?: string | null;
	rightPlayerId?: string | null;
	nextGameId?: string;
	tournamentRound: Game['tournamentRound'];
};

export class BracketGenerator {
	private db: PrismaClient | Prisma.TransactionClient;
	public static PLACEHOLDER_USER_ID = 'placeholder-tournament-user';

	constructor(db: PrismaClient | Prisma.TransactionClient) {
		this.db = db;
	}

	private async ensurePlaceholderUser(tx: Prisma.TransactionClient): Promise<string> {
		//TODO: is the placeholder user needed? can we just check for `userId` to be null?
		let user = await tx.user.findUnique({
			where: { id: BracketGenerator.PLACEHOLDER_USER_ID }
		});

		if (!user) {
			user = await tx.user.create({
				data: {
					id: BracketGenerator.PLACEHOLDER_USER_ID,
					email: PLACEHOLDER_EMAIL,
					username: EMPTY_SLOT_USERNAME,
				}
			});
		} else if (user.username !== EMPTY_SLOT_USERNAME) {
			await tx.user.update({
				where: { id: BracketGenerator.PLACEHOLDER_USER_ID },
				data: { username: EMPTY_SLOT_USERNAME }
			});
		}

		return user.id;
	}

	// TODO: gameId should be generated by database upon record creation
	async generateBracket(
		tournamentId: string,
		participants: string[] = []
	): Promise<BracketNode[]> {
		const bracket: BracketNode[] = [];
		const totalRounds = 3;
		const gameIdMap = new Map<string, string>();

		// Genera partite da finale a primo round
		for (let round = totalRounds; round >= 1; round--) {
			const gamesInRound = Math.pow(2, totalRounds - round);

			for (let position = 0; position < gamesInRound; position++) {
				const gameId = crypto.randomUUID();
				gameIdMap.set(`${round}-${position}`, gameId);

				let nextGameId: string | undefined;
				if (round < totalRounds) {
					nextGameId = gameIdMap.get(`${round + 1}-${Math.floor(position / 2)}`);
				}

				let leftPlayerId: string | null = null;
				let rightPlayerId: string | null = null;

				if (round === 1 && participants.length > 0) {
					const leftIndex = position * 2;
					const rightIndex = position * 2 + 1;

					if (leftIndex < participants.length) {
						leftPlayerId = participants[leftIndex];
					}
					if (rightIndex < participants.length) {
						rightPlayerId = participants[rightIndex];
					}
				}

				let tournamentRound: 'QUARTI' | 'SEMIFINALE' | 'FINALE';
				if (round === 3) {
					tournamentRound = 'FINALE';
				} else if (round === 2) {
					tournamentRound = 'SEMIFINALE';
				} else {
					tournamentRound = 'QUARTI';
				}

				bracket.push({
					gameId,
					round,
					position,
					leftPlayerId,
					rightPlayerId,
					nextGameId,
					tournamentRound
				});
			}
		}

		return bracket;
	}

	async createBracketGames(
		tournament: Tournament,
		bracket: BracketNode[]
	): Promise<void> {
		const executeTransaction = async (tx: Prisma.TransactionClient) => {
			const placeholderUserId = await this.ensurePlaceholderUser(tx);

			const sorted = [...bracket].sort((a, b) => b.round - a.round);

			for (const node of sorted) {
				let tournamentRound: 'QUARTI' | 'SEMIFINALE' | 'FINALE';
				if (node.round === 3) {
					tournamentRound = 'FINALE';
				} else if (node.round === 2) {
					tournamentRound = 'SEMIFINALE';
				} else {
					tournamentRound = 'QUARTI';
				}

				let leftPlayerUsername: string | null = EMPTY_SLOT_USERNAME;
				let leftPlayerId: string | null = BracketGenerator.PLACEHOLDER_USER_ID;
				let rightPlayerUsername: string | null = EMPTY_SLOT_USERNAME;
				let rightPlayerId: string | null = BracketGenerator.PLACEHOLDER_USER_ID;

				if (node.leftPlayerId && node.leftPlayerId !== BracketGenerator.PLACEHOLDER_USER_ID) {
					const leftUser = await tx.user.findUnique({
						where: { id: node.leftPlayerId },
						select: { username: true, id: true }
					});
					leftPlayerUsername = leftUser?.username || null;
					leftPlayerId = leftUser?.id || BracketGenerator.PLACEHOLDER_USER_ID;
				}

				if (node.rightPlayerId && node.rightPlayerId !== BracketGenerator.PLACEHOLDER_USER_ID) {
					const rightUser = await tx.user.findUnique({
						where: { id: node.rightPlayerId },
						select: { username: true, id: true }
					});
					rightPlayerUsername = rightUser?.username || null;
					rightPlayerId = rightUser?.id || BracketGenerator.PLACEHOLDER_USER_ID;
				}

				app.log.debug(`Creating game #${node.gameId} for tournament #${tournament.id} with round ${tournamentRound} and players ${node?.leftPlayerId ?? 'TBD'} vs ${node?.rightPlayerId ?? 'TBD'}`);

				await tx.game.create({
					data: {
						id: node.gameId,
						type: 'TOURNAMENT',
						tournamentRound: tournamentRound,
						startDate: null,
						scoreGoal: 5,
						tournamentId: tournament.id,
						leftPlayerId: leftPlayerId,
						rightPlayerId: rightPlayerId,
						leftPlayerUsername: leftPlayerUsername,
						rightPlayerUsername: rightPlayerUsername,
						nextGameId: node.nextGameId,
						leftPlayerScore: 0,
						rightPlayerScore: 0
					}
				});
			}
		};

		if (this.db instanceof PrismaClient) {
			await this.db.$transaction(executeTransaction);
		} else {
			await executeTransaction(this.db);
		}
	}

	//AI game
	async updateGameTypeForAIPlayers(tournamentId: string, tx?: Prisma.TransactionClient): Promise<void> {
		const executeTransaction = async (client: Prisma.TransactionClient) => {
			const aiPlayerService = new AIPlayerService(client);

			const games = await client.game.findMany({
				where: { tournamentId },
				select: {
					id: true,
					leftPlayerUsername: true,
					rightPlayerUsername: true
				}
			});

			for (const game of games) {
				const isLeftAI = aiPlayerService.isAIPlayer(game.leftPlayerUsername);
				const isRightAI = aiPlayerService.isAIPlayer(game.rightPlayerUsername);

				if (isLeftAI || isRightAI) {
					await client.game.update({
						where: { id: game.id },
						data: { type: 'AI' }
					});
					app.log.debug(`Game ${game.id} updated to AI type (left: ${isLeftAI}, right: ${isRightAI})`);
				}
			}
		};

		if (tx) {
			await executeTransaction(tx);
		} else if (this.db instanceof PrismaClient) {
			await this.db.$transaction(executeTransaction);
		} else {
			await executeTransaction(this.db);
		}
	}

	async generateAndCreateBracket(
		tournament: Tournament,
		participants: string[] = []
	): Promise<BracketNode[]> {
		const bracket = await this.generateBracket(tournament.id, participants);
		await this.createBracketGames(tournament, bracket);
		return bracket;
	}

	// Debug:
	printBracket(bracket: BracketNode[]): void {
		const rounds = new Map<number, BracketNode[]>();

		for (const node of bracket) {
			if (!rounds.has(node.round)) rounds.set(node.round, []);
			rounds.get(node.round)!.push(node);
		}

		app.log.debug('\n=== BRACKET ===\n');

		for (const round of Array.from(rounds.keys()).sort()) {
			const games = rounds.get(round)!.sort((a, b) => a.position - b.position);
			app.log.debug(`ROUND ${round}:`);

			for (const game of games) {
				const left = game.leftPlayerId ? `P${game.leftPlayerId.slice(-4)}` : 'TBD';
				const right = game.rightPlayerId ? `P${game.rightPlayerId.slice(-4)}` : 'TBD';
				const roundType = game.tournamentRound ? `[${game.tournamentRound}]` : '';
				const next = game.nextGameId ? ` â†’ Next` : ' [FINALE]';
				app.log.debug(`  Game ${game.position + 1} ${roundType}: ${left} vs ${right}${next}`);
			}
			app.log.debug('');
		}
	}

	getFirstRoundGames(bracket: BracketNode[]): BracketNode[] {
		return bracket.filter(node => node.round === 1);
	}

	getFinalGame(bracket: BracketNode[]): BracketNode | undefined {
		return bracket.find(node => !node.nextGameId);
	}

	async getBracketFromDatabase(tournamentId: string): Promise<BracketNode[]> {
		const games = await this.db.game.findMany({
			where: { tournamentId },
			orderBy: [
				{ startDate: 'asc' },
				{ id: 'asc' }
			]
		});

		const bracket: BracketNode[] = [];
		const gameMap = new Map<string, Game>();

		games.forEach((game) => {
			gameMap.set(game.id, game);
		});

		games.forEach((game) => {
			let round = 1;
			let currentGame: Game | undefined = game;

			while (currentGame.nextGameId) {
				round++;
				currentGame = gameMap.get(currentGame.nextGameId);
				if (!currentGame) break;
			}

			const gamesInRound = games.filter((g) => {
				let r = 1;
				let curr: Game | undefined = g;
				while (curr.nextGameId) {
					r++;
					curr = gameMap.get(curr.nextGameId);
					if (!curr) break;
				}
				return r === round;
			});

			const position = gamesInRound.findIndex((g) => g.id === game.id);

			bracket.push({
				gameId: game.id,
				round,
				position,
				leftPlayerId: game.leftPlayerId || null,
				rightPlayerId: game.rightPlayerId || null,
				nextGameId: game.nextGameId || undefined,
				tournamentRound: game.tournamentRound
			});
		});

		return bracket.sort((a, b) => a.round - b.round || a.position - b.position);
	}

	async getOccupiedSlotsCount(tournamentId: string): Promise<number> {
		const quarterFinalGames = await this.db.game.findMany({
			where: {
				tournamentId,
				tournamentRound: 'QUARTI' as any
			},
			select: {
				leftPlayerUsername: true,
				rightPlayerUsername: true
			}
		});

		let occupiedSlots = 0;
		const placeholderUserId = BracketGenerator.PLACEHOLDER_USER_ID;

		for (const game of quarterFinalGames) {
			if (game.leftPlayerUsername !== undefined &&
				game.leftPlayerUsername !== null &&
				game.leftPlayerUsername !== EMPTY_SLOT_USERNAME) {
				occupiedSlots++;
			}
			if (game.rightPlayerUsername !== undefined &&
				game.rightPlayerUsername !== null &&
				game.rightPlayerUsername !== EMPTY_SLOT_USERNAME) {
				occupiedSlots++;
			}
		}

		return occupiedSlots;
	}

	async getOccupiedSlots(tournamentId: string): Promise<Map<number, string>> {
		const games = await this.db.game.findMany({
			where: { tournamentId },
			select: {
				id: true,
				leftPlayerId: true,
				rightPlayerId: true,
				tournamentRound: true
			},
			orderBy: [
				{ tournamentRound: 'asc' },
				{ id: 'asc' }
			]
		});

		const slotMap = new Map<number, string>();
		let slotIndex = 0;

		for (const game of games) {
			if (game.leftPlayerId && !this.isPlaceholderUser(game.leftPlayerId)) {
				slotMap.set(slotIndex, game.leftPlayerId);
			}
			slotIndex++;

			if (game.rightPlayerId && !this.isPlaceholderUser(game.rightPlayerId)) {
				slotMap.set(slotIndex, game.rightPlayerId);
			}
			slotIndex++;
		}

		return slotMap;
	}

	private isPlaceholderUser(userId: string | null): boolean {
		if (!userId) return false;
		return userId === BracketGenerator.PLACEHOLDER_USER_ID ||
			userId === 'placeholder-tournament-user' ||
			userId.includes('placeholder');
	}

	async assignParticipantToSlot(tournamentId: string, participantId: string): Promise<void> {
		const executeTransaction = async (tx: Prisma.TransactionClient) => {
			const participant = await tx.user.findUnique({
				where: { id: participantId },
				select: { username: true }
			});

			if (!participant) {
				throw new Error(`Participant ${participantId} not found`);
			}

			const quarterFinalGames = await tx.game.findMany({
				where: {
					tournamentId,
					tournamentRound: 'QUARTI'
				},
				select: {
					id: true,
					leftPlayerId: true,
					rightPlayerId: true,
					leftPlayerUsername: true,
					rightPlayerUsername: true
				},
				orderBy: [
					{ startDate: 'asc' },
					{ id: 'asc' }
				]
			});

			const placeholderUserId = await this.ensurePlaceholderUser(tx);
			const availableSlots: { gameId: string, position: 'left' | 'right' }[] = [];

			app.log.debug('Quarter final games found:', quarterFinalGames.length);

			const isSlotEmpty = (playerId: string | null, username: string | null | undefined, placeholderId: string): boolean => {
				if (!playerId) return true;

				if (playerId === placeholderId) return true;

				if (playerId && username === null) return true;

				return false;
			};

			for (const game of quarterFinalGames) {
				if (isSlotEmpty(game.leftPlayerId, game.leftPlayerUsername, placeholderUserId)) {
					availableSlots.push({ gameId: game.id, position: 'left' as const });
				}
				if (isSlotEmpty(game.rightPlayerId, game.rightPlayerUsername, placeholderUserId)) {
					availableSlots.push({ gameId: game.id, position: 'right' as const });
				}
			}

			if (availableSlots.length === 0) {
				throw new Error('Nessun slot disponibile nei quarti di finale');
			}

			const randomIndex = Math.floor(Math.random() * availableSlots.length);
			const selectedSlot = availableSlots[randomIndex];

			const updateData = selectedSlot.position === 'left'
				? { leftPlayerId: participantId, leftPlayerUsername: participant.username }
				: { rightPlayerId: participantId, rightPlayerUsername: participant.username };

			await tx.game.update({
				where: { id: selectedSlot.gameId },
				data: updateData
			});
		};

		if (this.db instanceof PrismaClient) {
			await this.db.$transaction(executeTransaction);
		} else {
			await executeTransaction(this.db);
		}
	}

	async removeParticipantFromSlots(tournamentId: string, userId: string): Promise<void> {
		const executeTransaction = async (tx: Prisma.TransactionClient) => {
			const placeholderUserId = await this.ensurePlaceholderUser(tx);
			const games = await tx.game.findMany({
				where: {
					tournamentId,
					OR: [
						{ leftPlayerId: userId },
						{ rightPlayerId: userId }
					]
				},
				select: {
					id: true,
					leftPlayerId: true,
					rightPlayerId: true
				}
			});

			for (const game of games) {
				const updateData: Partial<Game> = {};

				if (game.leftPlayerId === userId) {
					updateData.leftPlayerId = placeholderUserId;
					updateData.leftPlayerUsername = EMPTY_SLOT_USERNAME;
				}

				if (game.rightPlayerId === userId) {
					updateData.rightPlayerId = placeholderUserId;
					updateData.rightPlayerUsername = EMPTY_SLOT_USERNAME;
				}

				if (Object.keys(updateData).length > 0) {
					await tx.game.update({
						where: { id: game.id },
						data: updateData
					});
				}
			}
		};

		if (this.db instanceof PrismaClient) {
			await this.db.$transaction(executeTransaction);
		} else {
			await executeTransaction(this.db);
		}
	}

	async fillEmptySlotsWithAIAndProgressAutomatically(tournamentId: string) {
		const placeholderUserId = await this.ensurePlaceholderUser(db);

		// FILLING QUARTI -> EMPTY SLOTS WITH AI (SETTING USERNAME TO NULL)
		await db.game.updateMany({
			where: {
				tournamentId: tournamentId,
				leftPlayerId: BracketGenerator.PLACEHOLDER_USER_ID,
				tournamentRound: TournamentRound.QUARTI,
			},
			data: {
				leftPlayerUsername: null,
			}
		});
		await db.game.updateMany({
			where: {
				tournamentId: tournamentId,
				rightPlayerId: BracketGenerator.PLACEHOLDER_USER_ID,
				tournamentRound: TournamentRound.QUARTI,
			},
			data: {
				rightPlayerUsername: null,
			}
		});

		// ALL TOURNAMENT GAMES
		const allGames = await db.game.findMany({
			where: {
				tournamentId,
			},
			orderBy: [
				{ startDate: 'asc' },
				{ id: 'asc' }
			],
			include: {
				leftPlayer: {
					select: {
						id: true,
						username: true
					}
				},
				rightPlayer: {
					select: {
						id: true,
						username: true
					}
				},
				previousGames: {
					select: {
						id: true
					}
				}
			},
		});

		// SORTED GAMES BY ROUND AND POSITION
		const mappedGames = mapTournamentGamesToDTO(allGames);

		const executeTransaction = async (tx: Prisma.TransactionClient) => {

			const checkIfLeftIsAI = (game: typeof allGames[0]) => game.leftPlayerUsername === null && game.leftPlayerId === BracketGenerator.PLACEHOLDER_USER_ID;
			const chekcIfRightIsAI = (game: typeof allGames[0]) => game.rightPlayerUsername === null && game.rightPlayerId === BracketGenerator.PLACEHOLDER_USER_ID;

			const skipAiVsAiGames = async (games: typeof allGames) => {
				for (const game of games) {
					const isLeftAi = checkIfLeftIsAI(game);
					const isRightAi = chekcIfRightIsAI(game);
					if (!isLeftAi || !isRightAi) {
						continue;
					}
					app.log.debug(`Autocompleting AI vs AI game #${game.id}
\tleft: ${isLeftAi} username: ${game.leftPlayerUsername} user: {id: ${game.leftPlayer?.id}, username: ${game.leftPlayer?.username}}
\tright: ${isRightAi} username: ${game.rightPlayerUsername}, user: {id: ${game.rightPlayer?.id}, username: ${game.rightPlayer?.username}}`);

					const winner = Math.random() < 0.5 ? 'left' : 'right';
					const leftScore = winner === 'left' ? game.scoreGoal : Math.floor(Math.random() * (game.scoreGoal));
					const rightScore = winner === 'right' ? game.scoreGoal : Math.floor(Math.random() * (game.scoreGoal));
					const updated = await tx.game.update({
						where: { id: game.id },
						data: {
							leftPlayerScore: leftScore,
							rightPlayerScore: rightScore,
							type: 'AI',
							endDate: new Date(),
							updatedAt: new Date(),

						}
					});
					allGames[allGames.findIndex(g => g.id === game.id)!] = { ...game, ...updated };


					const nextGameIdx = game.nextGameId ? allGames.findIndex(g => g.id === game.nextGameId) : -1;
					const nextGame = nextGameIdx !== -1 ? allGames[nextGameIdx] : null;

					if (nextGame) {
						let shouldBePlacedOnLeft = false;
						const [gameBeforeNextOnLeftSide] = mappedGames.filter(g => g.nextGameId === nextGame.id);
						if (gameBeforeNextOnLeftSide?.id === game.id) {
							shouldBePlacedOnLeft = true;
						}
						app.log.debug(`AIvsAI game #${game.id} has next game #${nextGame.id}. Placing the winner on the ${shouldBePlacedOnLeft ? 'left' : 'right'} side`);

						let updatedNextGame: Game;
						if (shouldBePlacedOnLeft) {
							updatedNextGame = await tx.game.update({
								where: { id: nextGame.id },
								data: {
									leftPlayerUsername: null,
								}
							});
						} else {
							updatedNextGame = await tx.game.update({
								where: { id: nextGame.id },
								data: {
									rightPlayerUsername: null,
								}
							});
						}
						allGames[nextGameIdx] = { ...nextGame, ...updatedNextGame };
					}
				}
			};

			await skipAiVsAiGames(allGames.filter(g => g.tournamentRound === 'QUARTI'));
			await skipAiVsAiGames(allGames.filter(g => g.tournamentRound === 'SEMIFINALE'));
			await skipAiVsAiGames(allGames.filter(g => g.tournamentRound === 'FINALE'));

			await this.updateGameTypeForAIPlayers(tournamentId, tx);
		};

		await db.$transaction(executeTransaction)
	}
}
